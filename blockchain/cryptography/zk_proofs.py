from py_ecc import bn128 # type: ignore
from hashlib import sha256
import random
import json

class ZeroKnowledgeProofs:
    """Implements basic Zero-Knowledge Proofs using zk-SNARK concepts and bn128 curve."""

    def __init__(self):
        # Generator point on the bn128 curve
        self.G = bn128.G1
        self.order = bn128.curve_order

    def hash_to_scalar(self, data):
        """
        Hashes the input data to a scalar value (used in zk proofs).
        :param data: The input data (string or bytes).
        :return: A scalar value derived from the hash.
        """
        if isinstance(data, str):
            data = data.encode('utf-8')
        hashed = sha256(data).hexdigest()
        return int(hashed, 16) % self.order

    def generate_proof(self, secret, statement):
        """
        Generates a Zero-Knowledge Proof for a given statement and secret.
        :param secret: The secret value (prover's knowledge).
        :param statement: The public statement (e.g., a commitment).
        :return: A proof object containing the necessary components.
        """
        secret_scalar = self.hash_to_scalar(secret)
        random_scalar = random.randint(1, self.order - 1)

        # Compute commitment and challenge
        commitment = bn128.multiply(self.G, random_scalar)
        challenge = self.hash_to_scalar(json.dumps((commitment, statement)))

        # Compute response
        response = (random_scalar + challenge * secret_scalar) % self.order

        return {
            "commitment": commitment,
            "challenge": challenge,
            "response": response,
            "statement": statement
        }

    def verify_proof(self, proof):
        """
        Verifies a Zero-Knowledge Proof.
        :param proof: The proof object generated by generate_proof.
        :return: True if the proof is valid, False otherwise.
        """
        commitment = proof["commitment"]
        challenge = proof["challenge"]
        response = proof["response"]
        statement = proof["statement"]

        # Recalculate the expected commitment
        expected_commitment = bn128.add(
            bn128.multiply(self.G, response),
            bn128.multiply(statement, -challenge)
        )

        # Verify if recalculated commitment matches the provided commitment
        if commitment == expected_commitment:
            print("Proof verified successfully.")
            return True
        else:
            print("Proof verification failed.")
            return False

    def generate_commitment(self, secret):
        """
        Generates a public commitment from a secret.
        :param secret: The secret value.
        :return: The commitment as a point on the bn128 curve.
        """
        secret_scalar = self.hash_to_scalar(secret)
        return bn128.multiply(self.G, secret_scalar)


# Example usage
if __name__ == "__main__":
    zk = ZeroKnowledgeProofs()

    # Example secret and its public commitment
    secret = "my_super_secret"
    commitment = zk.generate_commitment(secret)
    print("Public Commitment:", commitment)

    # Generate a Zero-Knowledge Proof for the secret
    proof = zk.generate_proof(secret, commitment)
    print("Generated Proof:", proof)

    # Verify the proof
    is_valid = zk.verify_proof(proof)
    print("Proof Valid:", is_valid)

    # Attempt verification with a tampered statement
    tampered_proof = proof.copy()
    tampered_proof["statement"] = bn128.multiply(zk.G, random.randint(1, zk.order - 1))
    is_valid = zk.verify_proof(tampered_proof)
    print("Tampered Proof Valid:", is_valid)
